package privileges

import (
	"fmt"
	"strings"

	"github.com/dalibo/ldap2pg/internal/normalize"
	"github.com/jackc/pgx/v5"
)

// ACL holds an ACL definition.
//
// An ACL is defined by a Scope and queries to inspect, grant and revoke items.
type ACL struct {
	Name    string
	Scope   string
	Inspect string
	Grant   string
	Revoke  string

	rowTo func(pgx.Row) (Grant, error)
}

func (a ACL) String() string {
	return a.Name
}

// Register ACL
//
// scope is one of instance, database, schema.
// Determines de granularity and relevant fields of the privilege.
//
// Grant and Revoke queries may be generated from Name.
func (a ACL) Register() error {
	if "GLOBAL DEFAULT" == a.Name {
		a.rowTo = rowToGlobalDefaultGrant
	} else if "SCHEMA DEFAULT" == a.Name {
		a.rowTo = rowToSchemaDefaultGrant
	} else if "instance" == a.Scope {
		a.rowTo = rowToInstanceGrant
	} else if "database" == a.Scope {
		a.rowTo = rowToDatabaseGrant
	} else {
		return fmt.Errorf("unknown scope %q", a.Scope)
	}

	g := Grant{
		ACL:      a.Name,
		Type:     "PRIV",
		Grantee:  "_grantee_",
		Owner:    "_owner_",
		Database: "_database_",
		Schema:   "_schema_",
		Object:   "_object_",
	}

	if g.FormatQuery(a.Grant).IsZero() {
		return fmt.Errorf("grant query is invalid")
	}
	if g.FormatQuery(a.Revoke).IsZero() {
		return fmt.Errorf("revoke query is invalid")
	}

	acls[a.Name] = a
	return nil
}

// MustRegister ACL
func (a ACL) MustRegister() {
	if err := a.Register(); err != nil {
		panic(fmt.Errorf("ACL: %s: %w", a.Name, err))
	}
}

func (a ACL) Uses(k string) bool {
	k = fmt.Sprintf("<%s>", k)
	return strings.Contains(a.Grant, k)
}

func (a ACL) RowTo(r pgx.Row) (Grant, error) {
	g, err := a.rowTo(r)

	if g.ACL == "" {
		g.ACL = a.Name
	}

	if a.Uses("object") {
		return g, err
	}

	// When granting on DATABASE or SCHEMA, move object to matching field.
	// This allows proper comparison with grant generated by rule.
	// Don't store database or schema in Object because rule expands them in ad-hoc fields.
	if a.Uses("database") {
		g.Database = g.Object
		g.Object = ""
	} else if g.Schema == "" && a.Uses("schema") {
		g.Schema = g.Object
		g.Object = ""
	}

	return g, err
}

func rowToGlobalDefaultGrant(r pgx.Row) (g Grant, err error) {
	// column order comes from statement:
	// ALTER DEFAULT PRIVILEGES FOR <owner> GRANT <type> ON <object> TO <grantee>;
	err = r.Scan(&g.Owner, &g.Type, &g.Object, &g.Grantee)
	return
}

func rowToSchemaDefaultGrant(r pgx.Row) (g Grant, err error) {
	// column order comes from statement:
	// ALTER DEFAULT PRIVILEGES FOR <owner> IN <schema> GRANT <type> ON <object> TO <grantee>;
	err = r.Scan(&g.Owner, &g.Schema, &g.Type, &g.Object, &g.Grantee)
	return
}

func rowToInstanceGrant(r pgx.Row) (g Grant, err error) {
	// column order comes from statement:
	// GRANT <type> ON ... <object> TO <grantee>;
	err = r.Scan(&g.Type, &g.Object, &g.Grantee)
	return
}

func rowToDatabaseGrant(r pgx.Row) (g Grant, err error) {
	err = r.Scan(&g.Type, &g.Object, &g.Grantee, &g.Partial)
	return
}

func NormalizeACLs(yaml interface{}) (interface{}, error) {
	m, ok := yaml.(map[string]interface{})
	if !ok {
		return yaml, fmt.Errorf("must be a map")
	}

	for k, v := range m {
		acl, ok := v.(map[string]interface{})
		if !ok {
			return yaml, fmt.Errorf("%s: must be a map", k)
		}
		err := normalize.SpuriousKeys(acl, "scope", "inspect", "grant", "revoke")
		if err != nil {
			return yaml, fmt.Errorf("%s: %w", k, err)
		}
	}

	return yaml, nil
}

// ACLs registry
var acls = make(map[string]ACL)

// managedACLs registry
//
// Lists all managed ACL and for each ACL, the managed privilege types.
// e.g. TABLES = [SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER]
//
// RegisterProfiles feed this map.
//
// Use this map to determine what to inspect and synchronize.
// Actually, use SplitManagedACLs to synchronize managed ACL by scope.
var managedACLs = map[string][]string{}

// SplitManagedACLs by scope
func SplitManagedACLs() (instancesACLs, databaseACLs, defaultACLs []string) {
	for n := range managedACLs {
		acl := acls[n]
		if acl.Uses("owner") {
			defaultACLs = append(defaultACLs, n)
		} else if acl.Scope == "instance" {
			instancesACLs = append(instancesACLs, n)
		} else {
			databaseACLs = append(databaseACLs, n)
		}
	}
	return
}
